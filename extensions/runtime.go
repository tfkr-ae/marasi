package extensions

import (
	"errors"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/Shopify/go-lua"
	"github.com/tfkr-ae/marasi/compass"
	"github.com/tfkr-ae/marasi/domain"
)

// ProxyService defines the interface that extensions use to interact with the core proxy.
// It provides a limited set of methods to ensure extensions cannot access or modify
// the proxy's internal state in unintended ways.
type ProxyService interface {
	GetConfigDir() (string, error)
	GetScope() (*compass.Scope, error)
	GetClient() (*http.Client, error)
	WriteLog(level string, message string, options ...func(log *domain.Log) error) error
	GetExtensionRepo() (domain.ExtensionRepository, error)
}

// ExtensionLog represents a single log entry generated by a Lua extension.
type ExtensionLog struct {
	Time time.Time // Time is the timestamp when the log entry was created.
	Text string    // Text is the content of the log message.
}

// LuaExtension represents a self-contained Lua extension environment.
// It holds the extension's data, its Lua state, logs, and provides thread-safe
// methods for interacting with the Lua runtime.
type LuaExtension struct {
	Data     *domain.Extension        // Data is the database model for the extension.
	LuaState *lua.State               // LuaState is the isolated Lua execution environment.
	Mu       sync.Mutex               // Mu is a mutex to ensure thread-safe access to the Lua state.
	Logs     []ExtensionLog           // Logs is a slice of log entries generated by the extension.
	OnLog    func(ExtensionLog) error `json:"-"` // OnLog is a callback function to handle new log entries.
}

// PrepareState initializes the Lua execution environment for the extension.
// It creates a new Lua state, opens a safe subset of standard libraries,
// registers all custom Go types and functions, and executes the extension's script.
// It also disables potentially dangerous Lua functions like `dofile` and `loadfile`
// to sandbox the extension.
func (extension *LuaExtension) PrepareState(proxy ProxyService, options []func(*LuaExtension) error) error {
	extension.LuaState = lua.NewState()
	lua.BaseOpen(extension.LuaState)
	lua.StringOpen(extension.LuaState)
	lua.TableOpen(extension.LuaState)
	lua.MathOpen(extension.LuaState)
	lua.Bit32Open(extension.LuaState)
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("loadfile")
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("dofile")
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("load")
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("require")

	// Register functions
	RegisterCustomPrint(extension)
	RegisterRequestType(extension)
	RegisterResponseType(extension)
	RegisterHeaderType(extension)
	RegisterCookieType(extension)
	RegisterRequestBuilderType(extension)
	RegisterRegexType(extension)
	RegisterScopeType(extension)
	extensionLibrary := func(l *lua.State) int {
		lua.NewLibrary(l, ExtensionLibrary(extension.LuaState, proxy, extension.Data.ID))
		return 1
	}
	lua.Require(extension.LuaState, "marasi/extension", extensionLibrary, true)
	extension.LuaState.Pop(1)
	extensionLibrary(extension.LuaState)
	extension.LuaState.SetGlobal("extension")
	marasiLibrary := func(l *lua.State) int {
		lua.NewLibrary(l, MarasiLibrary(extension.LuaState, proxy, extension.Data.ID))
		return 1
	}
	lua.Require(extension.LuaState, "marasi/marasi", marasiLibrary, true)
	extension.LuaState.Pop(1)
	marasiLibrary(extension.LuaState)
	extension.LuaState.SetGlobal("marasi")
	for _, option := range options {
		err := option(extension)
		if err != nil {
			log.Print(err)
		}
	}
	if err := lua.DoString(extension.LuaState, extension.Data.LuaContent); err != nil {
		return fmt.Errorf("preparing state for extension %s : %w", extension.Data.Name, err)
	}
	return nil
}

// CheckGlobalFlag checks for the existence and value of a boolean global variable in the Lua state.
// It returns true if the global exists and is set to true, otherwise false.
func (extension *LuaExtension) CheckGlobalFlag(globalName string) bool {
	extension.LuaState.Global(globalName)
	defer extension.LuaState.Pop(1)
	if isBoolean := extension.LuaState.IsBoolean(-1); isBoolean {
		return extension.LuaState.ToBoolean(-1)
	}
	return false
}

// GetGlobalFlag retrieves the value of a string global variable from the Lua state.
func (extension *LuaExtension) GetGlobalFlag(globalName string) (string, error) {
	extension.LuaState.Global(globalName)
	defer extension.LuaState.Pop(1)
	if flag, ok := extension.LuaState.ToString(-1); ok {
		return flag, nil
	}
	return "", fmt.Errorf("getting global flag %s", globalName)
}

// CheckGlobalFunction checks if a global variable of a given name exists and is a function.
func (extension *LuaExtension) CheckGlobalFunction(functionName string) bool {
	extension.LuaState.Global(functionName)
	defer extension.LuaState.Pop(1)
	return extension.LuaState.IsFunction(-1)
}

// ExecuteLua executes an arbitrary string of Lua code within the extension's sandboxed state.
// Access is mutex-locked to ensure thread safety.
func (extension *LuaExtension) ExecuteLua(code string) error {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()
	err := lua.DoString(extension.LuaState, code)
	if err != nil {
		return fmt.Errorf("executing string %s : %w", code, err)
	}
	return nil
}

// ShouldInterceptRequest calls the `interceptRequest` function in the Lua script
// to determine if the given HTTP request should be intercepted.
func (extension *LuaExtension) ShouldInterceptRequest(req *http.Request) (bool, error) {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()
	extension.LuaState.Global("interceptRequest")
	extension.LuaState.PushUserData(req)
	lua.SetMetaTableNamed(extension.LuaState, "req")
	err := extension.LuaState.ProtectedCall(1, 1, 0)
	if err != nil {
		return false, fmt.Errorf("calling shouldInterceptRequest : %w", err)
	}
	should := extension.LuaState.ToBoolean(-1)
	extension.LuaState.Pop(1)
	return should, nil
}

// ShouldInterceptResponse calls the `interceptResponse` function in the Lua script
// to determine if the given HTTP response should be intercepted.
func (extension *LuaExtension) ShouldInterceptResponse(res *http.Response) (bool, error) {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()
	extension.LuaState.Global("interceptResponse")
	extension.LuaState.PushUserData(res)
	lua.SetMetaTableNamed(extension.LuaState, "res")
	err := extension.LuaState.ProtectedCall(1, 1, 0)
	if err != nil {
		return false, fmt.Errorf("calling shouldInterceptResponse : %w", err)
	}
	should := extension.LuaState.ToBoolean(-1)
	extension.LuaState.Pop(1)
	return should, nil
}

// CallResponseHandler calls the `processResponse` function in the Lua script,
// passing the HTTP response to be processed by the extension.
func (extension *LuaExtension) CallResponseHandler(res *http.Response) error {
	extension.LuaState.Global("processResponse")
	extension.LuaState.PushUserData(res)
	lua.SetMetaTableNamed(extension.LuaState, "res")
	err := extension.LuaState.ProtectedCall(1, 0, 0)
	if err != nil {
		return fmt.Errorf("calling processResponse : %w", err)
	}
	return nil
}

// CallRequestHandler calls the `processRequest` function in the Lua script,
// passing the HTTP request to be processed by the extension.
func (extension *LuaExtension) CallRequestHandler(req *http.Request) error {
	extension.LuaState.Global("processRequest")
	extension.LuaState.PushUserData(req)
	lua.SetMetaTableNamed(extension.LuaState, "req")
	err := extension.LuaState.ProtectedCall(1, 0, 0)
	if err != nil {
		return fmt.Errorf("calling processRequest : %w", err)
	}
	return nil
}

// ExtensionWithLogHandler returns an option function to set a log handler on a LuaExtension.
// This handler is called whenever the extension's custom `print` function is used.
func ExtensionWithLogHandler(handler func(log ExtensionLog) error) func(*LuaExtension) error {
	return func(extension *LuaExtension) error {
		if extension.OnLog != nil {
			return errors.New("extension already has a log handler")
		}
		extension.OnLog = handler
		return nil
	}
}
