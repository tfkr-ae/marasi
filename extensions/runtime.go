package extensions

import (
	"errors"
	"fmt"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/Shopify/go-lua"
	"github.com/Shopify/goluago/util"
	"github.com/google/uuid"
	"github.com/tfkr-ae/marasi/compass"
	"github.com/tfkr-ae/marasi/domain"
)

// ProxyService defines the interface that extensions use to interact with the core proxy.
// It provides a limited set of methods to ensure extensions cannot access or modify
// the proxy's internal state in unintended ways.
type ProxyService interface {
	// GetConfigDir returns the path to the proxy's configuration directory.
	GetConfigDir() (string, error)
	// GetScope returns the proxy's current scope.
	GetScope() (*compass.Scope, error)
	// GetClient returns an HTTP client that can be used to make requests.
	GetClient() (*http.Client, error)
	// WriteLog writes a message to the proxy's log.
	WriteLog(level string, message string, options ...func(log *domain.Log) error) error
	// GetExtensionRepo returns the extension repository.
	GetExtensionRepo() (domain.ExtensionRepository, error)
	// GetTrafficRepo returns the traffic repository
	GetTrafficRepo() (domain.TrafficRepository, error)
}

// ExtensionLog represents a single log entry generated by a Lua extension.
type ExtensionLog struct {
	// Time is the timestamp when the log entry was created.
	Time time.Time
	// Text is the content of the log message.
	Text string
}

// Runtime represents a self-contained Lua extension environment.
// It holds the extension's data, its Lua state, logs, and provides thread-safe
// methods for interacting with the Lua runtime.
type Runtime struct {
	// Data is the database model for the extension.
	Data *domain.Extension
	// LuaState is the isolated Lua execution environment.
	LuaState *lua.State
	// Mu is a mutex to ensure thread-safe access to the Lua state.
	Mu sync.Mutex
	// Logs is a slice of log entries generated by the extension.
	Logs []ExtensionLog
	// OnLog is a callback function to handle new log entries.
	OnLog func(ExtensionLog) error `json:"-"`
}

// PrepareState initializes the Lua execution environment for the extension.
// It creates a new Lua state, opens a safe subset of standard libraries,
// registers all custom Go types and functions, and executes the extension's script.
// It also disables potentially dangerous Lua functions like `dofile` and `loadfile`
// to sandbox the extension.
func (extension *Runtime) PrepareState(proxy ProxyService, options []func(*Runtime) error) error {
	extension.LuaState = lua.NewState()
	extension.LuaState.PushString(extension.Data.ID.String())
	extension.LuaState.SetGlobal("extension_id")

	lua.BaseOpen(extension.LuaState)
	extension.LuaState.Pop(1)

	lua.TableOpen(extension.LuaState)
	extension.LuaState.SetGlobal("table")

	lua.MathOpen(extension.LuaState)
	extension.LuaState.SetGlobal("math")

	lua.Bit32Open(extension.LuaState)
	extension.LuaState.SetGlobal("bit32")

	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("loadfile")
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("dofile")
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("load")
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("require")
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("collectgarbage")

	// Register functions
	RegisterCustomPrint(extension)
	RegisterRequestType(extension)
	RegisterResponseType(extension)
	RegisterURLType(extension)
	RegisterHeaderType(extension)
	RegisterCookieType(extension)
	RegisterRequestBuilderType(extension)
	RegisterRegexType(extension)
	RegisterScopeType(extension)

	registerMarasiLibrary(extension.LuaState, proxy)

	for _, option := range options {
		err := option(extension)
		if err != nil {
			return fmt.Errorf("applying option for extension %s : %w", extension.Data.Name, err)
		}
	}
	if err := lua.DoString(extension.LuaState, extension.Data.LuaContent); err != nil {
		return fmt.Errorf("preparing state for extension %s : %w", extension.Data.Name, err)
	}

	if err := extension.CallFunction("startup"); err != nil {
		return fmt.Errorf("running startup for %s : %w", extension.Data.Name, err)
	}
	return nil
}

// GetGlobal returns the value of a global variable from the Lua state.
func (extension *Runtime) GetGlobal(name string) any {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()

	extension.LuaState.Global(name)
	defer extension.LuaState.Pop(1)

	return GoValue(extension.LuaState, -1)
}

// CheckGlobalFlag checks for the existence and value of a boolean global variable in the Lua state.
// It returns true if the global exists and is set to true, otherwise false.
func (extension *Runtime) CheckGlobalFlag(name string) bool {
	if val, ok := extension.GetGlobal(name).(bool); ok {
		return val
	}
	return false
}

// GetGlobalString returns the string value of a global variable from the Lua state.
func (extension *Runtime) GetGlobalString(name string) (string, error) {
	if val, ok := extension.GetGlobal(name).(string); ok {
		return val, nil
	}
	return "", fmt.Errorf("global %s is not a string", name)
}

// CheckGlobalFunction checks if a global variable of a given name exists and is a function.
func (extension *Runtime) CheckGlobalFunction(functionName string) bool {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()

	extension.LuaState.Global(functionName)
	defer extension.LuaState.Pop(1)

	return extension.LuaState.IsFunction(-1)
}

// ExecuteLua executes an arbitrary string of Lua code within the extension's sandboxed state.
// Access is mutex-locked to ensure thread safety.
func (extension *Runtime) ExecuteLua(code string) error {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()

	err := lua.DoString(extension.LuaState, code)
	if err != nil {
		return fmt.Errorf("executing string %s : %w", code, err)
	}

	return nil
}

// ShouldInterceptRequest calls the `interceptRequest` function in the Lua script
// to determine if the given HTTP request should be intercepted.
func (extension *Runtime) ShouldInterceptRequest(req *http.Request) (bool, error) {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()

	extension.LuaState.Global("interceptRequest")

	if !extension.LuaState.IsFunction(-1) {
		extension.LuaState.Pop(1)
		return false, nil
	}

	extension.LuaState.PushUserData(req)
	lua.SetMetaTableNamed(extension.LuaState, "req")

	err := extension.LuaState.ProtectedCall(1, 1, 0)
	if err != nil {
		extension.LuaState.Pop(1)
		return false, fmt.Errorf("calling shouldInterceptRequest : %w", err)
	}

	should := extension.LuaState.ToBoolean(-1)
	extension.LuaState.Pop(1)
	return should, nil
}

// ShouldInterceptResponse calls the `interceptResponse` function in the Lua script
// to determine if the given HTTP response should be intercepted.
func (extension *Runtime) ShouldInterceptResponse(res *http.Response) (bool, error) {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()
	extension.LuaState.Global("interceptResponse")

	if !extension.LuaState.IsFunction(-1) {
		extension.LuaState.Pop(1)
		return false, nil
	}

	extension.LuaState.PushUserData(res)
	lua.SetMetaTableNamed(extension.LuaState, "res")
	err := extension.LuaState.ProtectedCall(1, 1, 0)
	if err != nil {
		extension.LuaState.Pop(1)
		return false, fmt.Errorf("calling shouldInterceptResponse : %w", err)
	}
	should := extension.LuaState.ToBoolean(-1)
	extension.LuaState.Pop(1)
	return should, nil
}

// CallResponseHandler calls the `processResponse` function in the Lua script,
// passing the HTTP response to be processed by the extension.
func (extension *Runtime) CallResponseHandler(res *http.Response) error {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()

	extension.LuaState.Global("processResponse")

	if !extension.LuaState.IsFunction(-1) {
		extension.LuaState.Pop(1)
		return nil
	}

	extension.LuaState.PushUserData(res)
	lua.SetMetaTableNamed(extension.LuaState, "res")
	err := extension.LuaState.ProtectedCall(1, 0, 0)
	if err != nil {
		extension.LuaState.Pop(1)
		return fmt.Errorf("calling processResponse : %w", err)
	}
	return nil
}

// CallRequestHandler calls the `processRequest` function in the Lua script,
// passing the HTTP request to be processed by the extension.
func (extension *Runtime) CallRequestHandler(req *http.Request) error {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()

	extension.LuaState.Global("processRequest")

	if !extension.LuaState.IsFunction(-1) {
		extension.LuaState.Pop(1)
		return nil
	}

	extension.LuaState.PushUserData(req)
	lua.SetMetaTableNamed(extension.LuaState, "req")

	err := extension.LuaState.ProtectedCall(1, 0, 0)
	if err != nil {
		extension.LuaState.Pop(1)
		return fmt.Errorf("calling processRequest : %w", err)
	}
	return nil
}

// CallFunction executes a global Lua function by name with optional arguments.
// It is used for lifecycle events or simple triggers. If the function does not exist,
// it returns nil. If the function execution fails, it returns a formatted error.
func (extension *Runtime) CallFunction(name string, args ...any) error {
	extension.Mu.Lock()
	defer extension.Mu.Unlock()

	extension.LuaState.Global(name)

	if !extension.LuaState.IsFunction(-1) {
		extension.LuaState.Pop(1)
		return nil
	}

	for _, arg := range args {
		util.DeepPush(extension.LuaState, arg)
	}

	err := extension.LuaState.ProtectedCall(len(args), 0, 0)
	if err != nil {
		extension.LuaState.Pop(1)
		return fmt.Errorf("calling %s : %w", name, err)
	}
	return nil

}

// ExtensionWithLogHandler returns an option function to set a log handler on a LuaExtension.
// This handler is called whenever the extension's custom `print` function is used.
func ExtensionWithLogHandler(handler func(log ExtensionLog) error) func(*Runtime) error {
	return func(extension *Runtime) error {
		if extension.OnLog != nil {
			return errors.New("extension already has a log handler")
		}
		extension.OnLog = handler
		return nil
	}
}

// RegisterCustomPrint overrides the default Lua `print` function.
// The new function captures the output and sends it to the extension's log,
// making it visible in the Marasi UI.
func RegisterCustomPrint(extension *Runtime) {
	extension.LuaState.Register("print", func(l *lua.State) int {
		n := l.Top()
		parts := make([]string, 0, n)

		for i := 1; i <= n; i++ {
			val := PrintValue(l, i)
			if val == nil {
				parts = append(parts, "nil")
			} else {
				parts = append(parts, fmt.Sprintf("%v", val))
			}
		}

		msg := strings.Join(parts, "\t")
		entry := ExtensionLog{Time: time.Now(), Text: msg}
		extension.Logs = append(extension.Logs, entry)
		if extension.OnLog != nil {
			extension.OnLog(entry)
		}
		return 0
	})
}

func PrintValue(l *lua.State, index int) any {
	absIdx := index
	if index < 0 {
		absIdx = l.Top() + index + 1
	}
	switch l.TypeOf(absIdx) {
	case lua.TypeUserData:
		l.Global("tostring")
		l.PushValue(absIdx)
		l.Call(1, 1)

		str := lua.CheckString(l, -1)
		l.Pop(1)
		return str

	case lua.TypeTable:
		return ParseTable(l, absIdx, PrintValue)

	default:
		val := GoValue(l, absIdx)
		if val == nil && l.TypeOf(absIdx) != lua.TypeNil {
			return fmt.Sprintf("<%s>", l.TypeOf(absIdx).String())
		}
		return val
	}
}

// GetExtensionID retrieves and parses the "extension_id" global variable from the Lua state.
// It returns the parsed UUID if the global exists and is a valid UUID string.
// Returns uuid.Nil if the global is missing, not a string, or an invalid UUID.
func GetExtensionID(l *lua.State) uuid.UUID {
	l.Global("extension_id")
	defer l.Pop(1)

	if l.IsNil(-1) {
		return uuid.Nil
	}
	idString := lua.CheckString(l, -1)

	extID, err := uuid.Parse(idString)
	if err != nil {
		return uuid.Nil
	}
	return extID
}

func asMap(v any) map[string]any {
	if m, ok := v.(map[string]any); ok {
		return m
	}

	if s, ok := v.([]any); ok && len(s) == 0 {
		return make(map[string]any)
	}
	return nil
}

// GoValue converts a value at a specific stack index in the Lua state to its Go equivalent.
// It handles primitives (nil, boolean, number, string), tables (recursively via ParseTable),
// and UserData. For unsupported types (like functions or threads), it returns nil.
func GoValue(l *lua.State, index int) any {
	switch l.TypeOf(index) {
	case lua.TypeNil:
		return nil
	case lua.TypeBoolean:
		return l.ToBoolean(index)
	case lua.TypeNumber:
		f, _ := l.ToNumber(index)
		return f
	case lua.TypeString:
		s, _ := l.ToString(index)
		return s
	case lua.TypeTable:
		return ParseTable(l, index, GoValue)
	case lua.TypeUserData:
		return l.ToUserData(index)
	default:
		return nil
	}
}

// ParseTable converts a Lua table at the given index into a Go slice or map.
// If the table is a sequence (integer keys 1..N), it returns []any.
// Otherwise, it returns map[string]any, converting all keys to strings.
// The converter function allows custom value transformation; if nil, GoValue is used.
func ParseTable(l *lua.State, index int, converter func(*lua.State, int) any) any {
	if converter == nil {
		converter = GoValue
	}

	absIdx := index
	if index < 0 {
		absIdx = l.Top() + index + 1
	}

	intMap := make(map[int]any)
	strMap := make(map[string]any)

	isArray := true
	maxIndex := 0
	count := 0

	l.PushNil()
	for l.Next(absIdx) {
		val := converter(l, -1)

		switch l.TypeOf(-2) {
		case lua.TypeNumber:
			k, _ := l.ToNumber(-2)
			if float64(int(k)) == k && k >= 1 {
				intKey := int(k)
				intMap[intKey] = val
				if intKey > maxIndex {
					maxIndex = intKey
				}
			} else {
				isArray = false
				l.PushValue(-2)
				keyStr, _ := l.ToString(-1)
				l.Pop(1)

				strMap[keyStr] = val
			}
		case lua.TypeString:
			isArray = false
			k, _ := l.ToString(-2)
			strMap[k] = val
		default:
			isArray = false
			l.PushValue(-2)

			keyStr, _ := l.ToString(-1)
			l.Pop(1)

			strMap[keyStr] = val
		}
		count++

		l.Pop(1)
	}
	if isArray && maxIndex == count {
		slice := make([]any, maxIndex)
		for k, v := range intMap {
			slice[k-1] = v
		}
		if len(slice) == 0 {
			return []any{}
		}
		return slice
	}

	for k, v := range intMap {
		strMap[fmt.Sprintf("%d", k)] = v
	}

	return strMap
}
