package marasi

import (
	"errors"
	"fmt"
	"log"
	"net/http"
	"sync"
	"time"

	"github.com/Shopify/go-lua"
	"github.com/google/uuid"
)

// ExtensionLog represents a log entry generated by an extension during execution.
type ExtensionLog struct {
	Time time.Time // When the log entry was created
	Text string    // Log message content
}

// Extension represents a Lua-based extension that can process HTTP requests and responses.
// Extensions are isolated execution environments with their own Lua state and settings.
type Extension struct {
	ID          uuid.UUID              // Unique identifier for the extension
	Name        string                 // Human-readable name
	SourceURL   string                 `db:"source_url"` // URL of the extension's source repository
	Author      string                 // Extension author
	LuaContent  string                 `db:"lua_content"` // Lua script source code
	Enabled     bool                   // Whether the extension is active
	Description string                 // Extension description
	Settings    Metadata               // Extension-specific settings
	UpdatedAt   time.Time              `db:"update_at"` // Last update timestamp
	LuaState    *lua.State             // Lua execution state
	mu          sync.Mutex             // Mutex for thread-safe access
	Logs        []ExtensionLog         // Extension log entries
	OnLog       func(ExtensionLog) error `json:"-"` // Log callback function
}

// PrepareState initializes the Lua execution environment for the extension.
// It sets up the Lua state, opens standard libraries, registers custom types and functions,
// disables potentially dangerous functions, and executes the extension's Lua code.
//
// Parameters:
//   - proxy: The proxy instance to provide access to
//   - options: Additional configuration functions for the extension
//
// Returns:
//   - error: Initialization error if setup fails
func (extension *Extension) PrepareState(proxy *Proxy, options []func(*Extension) error) error {
	extension.LuaState = lua.NewState()
	//lua.OpenLibraries(extension.LuaState) // Ensure that Lua standard libraries are opened
	lua.BaseOpen(extension.LuaState)
	lua.StringOpen(extension.LuaState)
	lua.TableOpen(extension.LuaState)
	lua.MathOpen(extension.LuaState)
	lua.Bit32Open(extension.LuaState)
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("loadfile") // Disable 'loadfile'
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("dofile") // Disable 'dofile'
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("load") // Disable 'load'
	extension.LuaState.PushNil()
	extension.LuaState.SetGlobal("require") // Disable 'require'

	// Register functions
	RegisterCustomPrint(extension)
	RegisterRequestType(extension)
	RegisterResponseType(extension)
	RegisterProxyRequest(extension)
	RegisterProxyResponse(extension)
	RegisterHeaderType(extension)
	RegisterCookieType(extension)
	RegisterRequestBuilderType(extension)
	RegisterRegexType(extension)
	RegisterMapType(extension)
	RegisterScopeType(extension)
	extensionLibrary := func(l *lua.State) int {
		lua.NewLibrary(l, ExtensionLibrary(extension.LuaState, proxy, extension.ID))
		return 1
	}
	lua.Require(extension.LuaState, "marasi/extension", extensionLibrary, true)
	extension.LuaState.Pop(1)
	extensionLibrary(extension.LuaState)
	extension.LuaState.SetGlobal("extension")
	marasiLibrary := func(l *lua.State) int {
		lua.NewLibrary(l, MarasiLibrary(extension.LuaState, proxy, extension.ID))
		return 1
	}
	lua.Require(extension.LuaState, "marasi/marasi", marasiLibrary, true)
	extension.LuaState.Pop(1)
	marasiLibrary(extension.LuaState)
	extension.LuaState.SetGlobal("marasi")
	for _, option := range options {
		err := option(extension)
		if err != nil {
			log.Print(err)
		}
	}
	if err := lua.DoString(extension.LuaState, extension.LuaContent); err != nil {
		return fmt.Errorf("preparing state for extension %s : %w", extension.Name, err)
	}
	return nil
}

/*
Test Cases:
- Ensure that the global flag is checked correctly
- Ensure that the global flag is a boolean
- Test if the global flag is false
- Test if the global flag does not exist
*/
func (extension *Extension) CheckGlobalFlag(globalName string) bool {
	extension.LuaState.Global(globalName)
	defer extension.LuaState.Pop(1)
	if isBoolean := extension.LuaState.IsBoolean(-1); isBoolean {
		return extension.LuaState.ToBoolean(-1)
	}
	return false
}

/*
Test Cases:
- Test if the global flag is a string
- Test if the global flag is not a string
- Test after the global flag is set
*/
func (extension *Extension) GetGlobalFlag(globalName string) (string, error) {
	extension.LuaState.Global(globalName)
	defer extension.LuaState.Pop(1)
	if flag, ok := extension.LuaState.ToString(-1); ok {
		return flag, nil
	}
	return "", fmt.Errorf("getting global flag %s", globalName)
}

/*
Test Cases:
- Test if the global function exists
- Test if the global function does not exist
- Test if the global function is not a function
*/
func (extension *Extension) CheckGlobalFunction(functionName string) bool {
	extension.LuaState.Global(functionName)
	defer extension.LuaState.Pop(1)
	return extension.LuaState.IsFunction(-1)
}

/*
Test Cases:
- Test if the lua code is executed correctly
*/
func (extension *Extension) ExecuteLua(code string) error {
	extension.mu.Lock()
	defer extension.mu.Unlock()
	err := lua.DoString(extension.LuaState, code)
	if err != nil {
		return fmt.Errorf("executing string %s : %w", code, err)
	}
	return nil
}

/*
Test Cases:
- Test if a request matching the rule is intercepted
- Test if the request not matching the rule is not intercepted
*/
func (extension *Extension) ShouldInterceptRequest(req *http.Request) (bool, error) {
	extension.mu.Lock()
	defer extension.mu.Unlock()
	extension.LuaState.Global("interceptRequest")
	extension.LuaState.PushUserData(req)
	lua.SetMetaTableNamed(extension.LuaState, "req")
	err := extension.LuaState.ProtectedCall(1, 1, 0)
	if err != nil {
		return false, fmt.Errorf("calling shouldInterceptRequest : %w", err)
	}
	should := extension.LuaState.ToBoolean(-1)
	extension.LuaState.Pop(1)
	return should, nil
}

/*
Test Cases:
- Test if a response matching the rule is intercepted
- Test if the response not matching the rule is not intercepted
*/
func (extension *Extension) ShouldInterceptResponse(res *http.Response) (bool, error) {
	extension.mu.Lock()
	defer extension.mu.Unlock()
	extension.LuaState.Global("interceptResponse")
	extension.LuaState.PushUserData(res)
	lua.SetMetaTableNamed(extension.LuaState, "res")
	err := extension.LuaState.ProtectedCall(1, 1, 0)
	if err != nil {
		return false, fmt.Errorf("calling shouldInterceptResponse : %w", err)
	}
	should := extension.LuaState.ToBoolean(-1)
	extension.LuaState.Pop(1)
	return should, nil
}

/*
Test Cases:
- Test if the response handler is called correctly
- Test if the response handler is not a function
*/
func (extension *Extension) CallResponseHandler(res *http.Response) error {
	extension.LuaState.Global("processResponse")
	extension.LuaState.PushUserData(res)
	lua.SetMetaTableNamed(extension.LuaState, "res")
	err := extension.LuaState.ProtectedCall(1, 0, 0)
	if err != nil {
		return fmt.Errorf("calling processResponse : %w", err)
	}
	return nil
}

/*
Test Cases:
- Test if the request handler is called correctly
- Test if the request handler is not a function
*/
func (extension *Extension) CallRequestHandler(req *http.Request) error {
	extension.LuaState.Global("processRequest")
	extension.LuaState.PushUserData(req)
	lua.SetMetaTableNamed(extension.LuaState, "req")
	err := extension.LuaState.ProtectedCall(1, 0, 0)
	if err != nil {
		return fmt.Errorf("calling processRequest : %w", err)
	}
	return nil
}

func ExtensionWithLogHandler(handler func(log ExtensionLog) error) func(*Extension) error {
	return func(extension *Extension) error {
		if extension.OnLog != nil {
			return errors.New("extension already has a log handler")
		}
		extension.OnLog = handler
		return nil
	}
}
